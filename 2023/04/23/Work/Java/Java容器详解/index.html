

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="https://longls777.oss-cn-beijing.aliyuncs.com/img/fluid.png">
  <link rel="icon" href="https://longls777.oss-cn-beijing.aliyuncs.com/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Aaron">
  <meta name="keywords" content="life, think, code">
  
    <meta name="description" content="一、概览  容器主要包括 Collection 和 Map 两种，Collection 是存储着对象的集合，而 Map 存储着键值对（两个对象）的映射表 Collection   Set   TreeSet：基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN) HashS">
<meta property="og:type" content="article">
<meta property="og:title" content="Java集合详解">
<meta property="og:url" content="https://lishilong.site/2023/04/23/Work/Java/Java%E5%AE%B9%E5%99%A8%E8%AF%A6%E8%A7%A3/index.html">
<meta property="og:site_name" content="Heart">
<meta property="og:description" content="一、概览  容器主要包括 Collection 和 Map 两种，Collection 是存储着对象的集合，而 Map 存储着键值对（两个对象）的映射表 Collection   Set   TreeSet：基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN) HashS">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://longls777.oss-cn-beijing.aliyuncs.com/img/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%9B%BE.png">
<meta property="og:image" content="http://longls777.oss-cn-beijing.aliyuncs.com/img/Collection.png">
<meta property="og:image" content="http://longls777.oss-cn-beijing.aliyuncs.com/img/Map.png">
<meta property="og:image" content="http://longls777.oss-cn-beijing.aliyuncs.com/img/image-20191208232221265.png">
<meta property="og:image" content="http://longls777.oss-cn-beijing.aliyuncs.com/img/xmmm.png">
<meta property="og:image" content="http://longls777.oss-cn-beijing.aliyuncs.com/img/LinkedList.png">
<meta property="og:image" content="http://longls777.oss-cn-beijing.aliyuncs.com/img/HashMap.png">
<meta property="og:image" content="http://longls777.oss-cn-beijing.aliyuncs.com/img/HashMap%E7%BB%93%E6%9E%84.png">
<meta property="og:image" content="http://longls777.oss-cn-beijing.aliyuncs.com/img/20170805175826627">
<meta property="og:image" content="http://longls777.oss-cn-beijing.aliyuncs.com/img/20170805175936719">
<meta property="og:image" content="http://longls777.oss-cn-beijing.aliyuncs.com/img/20170805180104619">
<meta property="og:image" content="http://longls777.oss-cn-beijing.aliyuncs.com/img/ConcurrentHashMap%E5%82%A8%E5%AD%98%E7%BB%93%E6%9E%84.png">
<meta property="og:image" content="http://longls777.oss-cn-beijing.aliyuncs.com/img/ConcurrentHashMap%E7%BB%93%E6%9E%84.png">
<meta property="og:image" content="http://longls777.oss-cn-beijing.aliyuncs.com/img/ConcurrentHashMap1.7.png">
<meta property="og:image" content="http://longls777.oss-cn-beijing.aliyuncs.com/img/ConcurrentHashMap1.png">
<meta property="og:image" content="http://longls777.oss-cn-beijing.aliyuncs.com/img/ConcurrentHashMap2.png">
<meta property="og:image" content="http://longls777.oss-cn-beijing.aliyuncs.com/img/ConcurrentHashMap1.8_.png">
<meta property="article:published_time" content="2023-04-23T08:21:00.000Z">
<meta property="article:modified_time" content="2024-10-29T07:19:40.563Z">
<meta property="article:author" content="Aaron">
<meta property="article:tag" content="八股">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://longls777.oss-cn-beijing.aliyuncs.com/img/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%9B%BE.png">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>Java集合详解 - Heart</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/KaTeX/0.15.6/katex.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"lishilong.site","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"gtag":null},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  

  



  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Heart</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://longls777.oss-cn-beijing.aliyuncs.com/img/banner.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Java集合详解"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-04-23 16:21" pubdate>
          2023年4月23日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          12k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          97 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Java集合详解</h1>
            
            
              <div class="markdown-body">
                
                <h1>一、概览</h1>
<p><img src="http://longls777.oss-cn-beijing.aliyuncs.com/img/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%9B%BE.png" srcset="/img/loading.gif" lazyload alt="Java集合框架图"></p>
<p>容器主要包括 Collection 和 Map 两种，Collection 是存储着对象的集合，而 Map 存储着键值对（两个对象）的映射表</p>
<p><strong>Collection</strong></p>
<p><img src="http://longls777.oss-cn-beijing.aliyuncs.com/img/Collection.png" srcset="/img/loading.gif" lazyload alt="Collection"></p>
<ol>
<li>Set</li>
</ol>
<ul>
<li>TreeSet：基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)</li>
<li>HashSet：基于HashMap实现，不能存入重复元素，不能get，只能遍历，且使用 Iterator 遍历 HashSet 得到的结果不确定，也就是说失去了元素的插入顺序信息。Hash冲突参照HashMap的处理方法(拉链法，红黑树)</li>
<li>LinkedHashSet：具有 HashSet 的查找效率，并且内部使用双向链表维护元素的插入顺序</li>
</ul>
<ol start="2">
<li>List</li>
</ol>
<ul>
<li>ArrayList：基于动态数组实现，支持随机访问</li>
<li>Vector：和 ArrayList 类似，但它是线程安全的</li>
<li>LinkedList：基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列</li>
</ul>
<ol start="3">
<li>Queue</li>
</ol>
<ul>
<li>LinkedList：可以用它来实现双向队列</li>
<li>PriorityQueue：基于堆结构实现，可以用它来实现优先队列</li>
</ul>
<p><strong>Map</strong></p>
<p><img src="http://longls777.oss-cn-beijing.aliyuncs.com/img/Map.png" srcset="/img/loading.gif" lazyload alt="Map"></p>
<ul>
<li>TreeMap：基于红黑树实现</li>
<li>HashMap：基于哈希表实现</li>
<li>HashTable：和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程同时写入 HashTable 不会导致数据不一致。它是遗留类，不应该去使用它，而是使用 ConcurrentHashMap 来支持线程安全，ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁</li>
<li>LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序</li>
</ul>
<h1>二、ArrayList</h1>
<p><strong>1. 说说ArrayList是如何实现的？</strong></p>
<p><img src="http://longls777.oss-cn-beijing.aliyuncs.com/img/image-20191208232221265.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>ArrayList 的底层是数组队列，相当于<strong>动态数组</strong>。与 Java 中的数组相比，它的容量能动态增长。在添加大量元素前，应用程序可以使用ensureCapacity操作来增加 ArrayList 实例的容量。这可以减少递增式再分配的数量</p>
<p>ArrayList继承于 AbstractList，实现了 List，RandomAccess，Cloneable，java.io.Serializable 这些接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayList</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractList</span>&lt;E&gt;<br>        <span class="hljs-keyword">implements</span> <span class="hljs-title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123;<br>  &#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>RandomAccess 是一个标志接口，表明实现这个这个接口的 List 集合是<strong>支持快速随机访问</strong>的。在 ArrayList 中，我们即可以通过元素的序号快速获取元素对象，这就是快速随机访问</li>
<li>ArrayList 实现了 Cloneable 接口 ，即重写了函数clone()，能被克隆</li>
<li>ArrayList 实现了 java.io.Serializable 接口，这意味着ArrayList支持序列化，能通过序列化去传输</li>
</ul>
<p><strong>2. 说说ArrayList的扩容机制？</strong></p>
<p><strong>重点流程：</strong></p>
<ol>
<li>
<p>调用add()方法时，调用ensureCapacityInternal（size+1），判断需要的最小容量（如果采用默认无参构造创建ArrayList，则在添加第一个元素时，将数组容量扩充为10）</p>
</li>
<li>
<p>如果最小容量大于数组长度，则进入grow()方法</p>
</li>
<li>
<p>在grow()方法中，默认新容量为旧容量的1.5倍左右(oldCapacity为偶数就是1.5倍)</p>
</li>
<li>
<ol>
<li>
<p>如果新容量仍小于所需最小容量，则扩容为所需最小容量</p>
</li>
<li>
<p>如果新容量大于MAX_ARRAY_SIZE（Integer.MAX_VALUE-8）：</p>
</li>
<li>
<ol>
<li>如果所需最小容量大于MAX_ARRAY_SIZE，扩容为Integer.MAX_VALUE</li>
<li>否则，扩容为MAX_ARRAY_SIZE</li>
</ol>
</li>
</ol>
</li>
<li>
<p>调用Arrays.copy()方法，复制并扩容数组</p>
</li>
<li>
<p>可以在大量add()操作之前调用ensureCapacity（）方法，以提前扩容，避免多次扩容</p>
</li>
</ol>
<p><strong>详细分析：</strong></p>
<p><strong>先来看add()方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 将指定的元素追加到此列表的末尾。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-comment">//添加元素之前，先调用ensureCapacityInternal方法</span><br>    ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span><br>    <span class="hljs-comment">//这里看到ArrayList添加元素的实质就相当于为数组赋值</span><br>    elementData[size++] = e;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>再来看 ensureCapacityInternal() 方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//得到最小扩容量</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;<br>              <span class="hljs-comment">// 获取默认的容量和传入参数的较大值</span><br>            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);<br>   &#125;<br><br>   ensureExplicitCapacity(minCapacity);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>当add 进第 1 个元素时，minCapacity 为 1，在 Math.max()方法比较后，minCapacity 为 10，就是说：</p>
<p>以无参数构造方式创建ArrayList时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为10</p>
<p><strong>ensureExplicitCapacity() 方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//判断是否需要扩容</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureExplicitCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>   modCount++;<span class="hljs-comment">//操作数+1</span><br>    <br>    <span class="hljs-comment">//考虑int溢出</span><br>  <span class="hljs-comment">// overflow-conscious code</span><br>  <span class="hljs-keyword">if</span> (minCapacity - elementData.length &gt; <span class="hljs-number">0</span>)<br>     <span class="hljs-comment">//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span><br>     grow(minCapacity);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>grow() 方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 要分配的最大数组大小</span><br><span class="hljs-comment">*/</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_ARRAY_SIZE</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE - <span class="hljs-number">8</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * ArrayList扩容的核心方法。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">grow</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>        <span class="hljs-comment">// oldCapacity为旧容量，newCapacity为新容量</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">oldCapacity</span> <span class="hljs-operator">=</span> elementData.length;<br>        <span class="hljs-comment">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span><br>        <span class="hljs-comment">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span><br>        <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>)<br>            newCapacity = minCapacity;<br>       <span class="hljs-comment">// 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，</span><br>       <span class="hljs-comment">//如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。</span><br>        <span class="hljs-keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)<br>            newCapacity = hugeCapacity(minCapacity);<br>        <span class="hljs-comment">// minCapacity is usually close to size, so this is a win:</span><br>        elementData = Arrays.copyOf(elementData, newCapacity);<br>    &#125;<br></code></pre></td></tr></table></figure>
<p><img src="http://longls777.oss-cn-beijing.aliyuncs.com/img/xmmm.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p><strong>hugeCapacity() 方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hugeCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>        <span class="hljs-keyword">if</span> (minCapacity &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OutOfMemoryError</span>();<br>        <span class="hljs-comment">//对minCapacity和MAX_ARRAY_SIZE进行比较</span><br>        <span class="hljs-comment">//若minCapacity大，将Integer.MAX_VALUE作为新数组的大小</span><br>        <span class="hljs-comment">//若MAX_ARRAY_SIZE大，将MAX_ARRAY_SIZE作为新数组的大小</span><br>        <span class="hljs-comment">//MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</span><br>        <span class="hljs-keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?<br>            Integer.MAX_VALUE :<br>            MAX_ARRAY_SIZE;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>最好在 add 大量元素之前用 ensureCapacity 方法，以减少增量重新分配的次数</p>
<p><strong>ensureCapacity()方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">   如有必要，增加此 ArrayList 实例的容量，以确保它至少可以容纳由minimum capacity参数指定的元素数。</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span>   minCapacity   所需的最小容量</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">minExpand</span> <span class="hljs-operator">=</span> (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)<br>           <span class="hljs-comment">// any size if not default element table</span><br>           ? <span class="hljs-number">0</span><br>           <span class="hljs-comment">// larger than default for default empty table. It&#x27;s already</span><br>           <span class="hljs-comment">// supposed to be at default size.</span><br>           : DEFAULT_CAPACITY;<br><br>       <span class="hljs-keyword">if</span> (minCapacity &gt; minExpand) &#123;<br>           ensureExplicitCapacity(minCapacity);<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure>
<h1>三、LinkedList</h1>
<p><strong>1. 说说LinkedList？</strong></p>
<p><img src="http://longls777.oss-cn-beijing.aliyuncs.com/img/LinkedList.png" srcset="/img/loading.gif" lazyload alt="LinkedList"></p>
<ul>
<li>LinkedList是一个实现了List接口和Deque接口的双端链表</li>
<li>LinkedList底层的链表结构使它支持高效的插入和删除操作，另外它实现了Deque接口，使得LinkedList类也具有队列的特性</li>
<li>使用队列用Queue；使用堆栈用Deque</li>
</ul>
<p><strong>2. 说说Arraylist 与 LinkedList 的区别?</strong></p>
<ol>
<li><strong>是否保证线程安全</strong>： ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；</li>
<li><strong>底层数据结构</strong>： Arraylist 底层使用的是 Object 数组；LinkedList 底层使用的是 双向链表 （JDK1.6 之前为循环链表）</li>
<li><strong>插入和删除是否受元素位置的影响</strong>：
<ol>
<li>ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行add(E e)方法的时候， ArrayList 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（add(int index, E element)）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作</li>
<li>LinkedList 采用链表存储，所以对于add(E e)方法的插入，删除元素时间复杂度不受元素位置的影响，近似 O(1)，如果是要在指定位置i插入和删除元素的话（(add(int index, E element)） 时间复杂度近似为O(n)因为需要先移动到指定位置再插入</li>
</ol>
</li>
<li><strong>是否支持快速随机访问</strong>： LinkedList 不支持高效的随机元素访问，而 ArrayList 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于get(int index)方法)</li>
<li><strong>内存空间占用</strong>： ArrayList 的空间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）</li>
</ol>
<h1>四、HashMap</h1>
<p><strong>1. 说说HashMap的原理？</strong></p>
<p><img src="http://longls777.oss-cn-beijing.aliyuncs.com/img/HashMap.png" srcset="/img/loading.gif" lazyload alt="HashMap"></p>
<p>JDK1.8 之前 HashMap 由 数组+链表 组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）</p>
<p>JDK1.8 开始 HashMap 的组成多了红黑树，在满足下面两个条件之后，会执行链表转红黑树操作，以此来加快搜索速度</p>
<ul>
<li>链表长度大于阈值（默认为 8）</li>
<li>HashMap 的Node数组（也就是上图的table）长度超过 64</li>
</ul>
<p><strong>2. HashMap的键值可以为null吗</strong></p>
<p>HashMap最多只允许一条Node的key为Null，但允许多条Node的value为Null</p>
<p><strong>3. HashMap储存的是Java对象实例吗？</strong></p>
<p>虽然容器号称存储的是 Java 对象，但实际上并不会真正将 Java 对象放入容器中，只是在容器中保留这些对象的引用。也就是说，Java 容器实际上包含的是引用变量，而这些引用变量指向了我们要实际保存的 Java 对象</p>
<p><strong>4. 说说HashMap的构造函数？</strong></p>
<p>HashMap 一共提供了四个构造函数，其中 默认无参的构造函数 和 参数为Map的构造函数 为 Java Collection Framework 规范的推荐实现，其余两个构造函数则是 HashMap 专门提供的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//无参构造函数，仅仅将负载因子初始化为默认值，而不会初始化Node数组，</span><br><span class="hljs-comment">///也就是说，当使用无参构造函数创建HashMap时，HashMap的容量（Node数组长度）和大小（size）都为0</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">HashMap</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <br>    <span class="hljs-comment">// all other fields defaulted</span><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">HashMap</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity)</span> &#123;<br>    <span class="hljs-built_in">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>**HashMap(int initialCapacity, float loadFactor)**构造函数意在构造一个指定初始容量和指定负载因子的空HashMap，其源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">HashMap</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity, <span class="hljs-type">float</span> loadFactor)</span> &#123;<br>    <span class="hljs-keyword">if</span> (initialCapacity &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal initial capacity: &quot;</span> +<br>                                           initialCapacity);<br>    <span class="hljs-comment">//容量最大为2的30次方</span><br>    <span class="hljs-keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)<br>        initialCapacity = MAXIMUM_CAPACITY;<br>    <span class="hljs-keyword">if</span> (loadFactor &lt;= <span class="hljs-number">0</span> || Float.isNaN(loadFactor))<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal load factor: &quot;</span> +<br>                                           loadFactor);<br>    <span class="hljs-built_in">this</span>.loadFactor = loadFactor;<br>    <span class="hljs-comment">//这里调用函数计算触发扩容的阈值，threshold/loadFactor就是容量</span><br>    <span class="hljs-built_in">this</span>.threshold = tableSizeFor(initialCapacity);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>tableSizeFor()<strong>方法源码如下，从注释就可以看出来，其</strong>目的是要获得大于等于cap的最小的2的幂</strong>。比如cap=10，则返回16。这里给threshold赋初值而并没有初始化Node数组的容量，那么这个initialCapacity是如何起作用的呢？</p>
<p>答案在resize函数中，<strong>扩容时如果Node数组没有初始化而threshold &gt; 0，那么就会将Node数组初始化为threshold的大小，之后再将threshold更新为length*loadFactor。这样就可以达到，“传入一个初始容量，HashMap中的数组大小初始化为大于等于初始容量的最小二次幂”</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Returns a power of two size for the given target capacity.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tableSizeFor</span><span class="hljs-params">(<span class="hljs-type">int</span> cap)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> cap - <span class="hljs-number">1</span>;<span class="hljs-comment">//减1是为了让结果&gt;=cap,如cap=8=1000b,不减1而直接操作，最后会得到16=10000b</span><br>    n |= n &gt;&gt;&gt; <span class="hljs-number">1</span>;<span class="hljs-comment">//假设n=001..xxxx 逻辑右移一位并按位或得 0011..xxxx</span><br>    n |= n &gt;&gt;&gt; <span class="hljs-number">2</span>;<span class="hljs-comment">//同理 得到 001111..xxxx</span><br>    n |= n &gt;&gt;&gt; <span class="hljs-number">4</span>;<span class="hljs-comment">// 0011111111..xxxx</span><br>    n |= n &gt;&gt;&gt; <span class="hljs-number">8</span>;<span class="hljs-comment">//接下来同理，可以看到1+2+4+8+16=31，而cap为32位，就是说会把最高位的1之后全置为1</span><br>    n |= n &gt;&gt;&gt; <span class="hljs-number">16</span>;<span class="hljs-comment">//最后再让n+1，就可以得到&gt;=cap的2的最小整数次幂了</span><br>    <span class="hljs-keyword">return</span> (n &lt; <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>5. 说说HashMap的数据结构？</strong></p>
<p><img src="http://longls777.oss-cn-beijing.aliyuncs.com/img/HashMap%E7%BB%93%E6%9E%84.png" srcset="/img/loading.gif" lazyload alt="HashMap结构"></p>
<p>在JDK1.6和JDK1.7中，HashMap采用<strong>数组+链表</strong>实现，即使用链表处理冲突，同一hash值的key-value键值对都存储在一个链表里。但是当数组中一个位置上的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低 <strong>O(n)</strong></p>
<p>而在JDK1.8中，HashMap采用<strong>数组+链表+红黑树</strong>实现，当链表长度超过阈值8时，并且数组总容量超过64时，将链表转换为红黑树，这样大大减少了查找时间 <strong>O(logn)</strong></p>
<p>而当发生扩容或remove键值对导致原有的红黑树内节点数量小于6时，则又将红黑树转换成链表</p>
<p><strong>6. 说说HashMap的put方法？</strong></p>
<p><strong>JDK1.8</strong></p>
<p>HashMap 通过 key 的 hashCode 经过<strong>扰动函数处理</strong>过后得到 hash 值，然后通过 <strong>(n - 1) &amp; hash</strong> 判断当前元素存放的位置，这里的 n 指的是数组的长度，相当于<strong>对hash值除n取余</strong></p>
<p>为什么hash &amp; （n-1）相当于对hash除n取余？原因是Node数组的默认容量是16，随后每次扩容都乘2，也就是说n一直都是2的幂，例如对8取余，不就是&amp;0111吗？ 早期CPU都是使用这样的方式计算余数 ：X &amp; (2^N - 1)，这种方式效率比较高</p>
<ol>
<li>如果定位到的数组位置没有元素 就直接插入</li>
<li>如果定位到的数组位置有元素就和要插入的 key 使用equals比较，如果 key 相同就直接覆盖并返回旧Value，如果 key 不相同，就判断 p 是否是一个树节点，如果是就调用e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value)将元素插入。如果不是就遍历链表插入（<strong>插入的是链表尾部</strong>）</li>
<li>如果在链表插入过程中发现链表长度达到阈值（默认是8），会进入treeifyBin方法判断是否需要转化为红黑树，如果数组长度小于64就先扩容（resize）</li>
<li>在put方法中，最后如果发现实际大小大于阈值则扩容</li>
</ol>
<p><strong>JDK1.7</strong></p>
<p>使用拉链法时采用的是头插法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;<br>    <span class="hljs-keyword">return</span> putVal(hash(key), key, value, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);<br>&#125;<br><br><span class="hljs-keyword">final</span> V <span class="hljs-title function_">putVal</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, K key, V value, <span class="hljs-type">boolean</span> onlyIfAbsent,</span><br><span class="hljs-params">                   <span class="hljs-type">boolean</span> evict)</span> &#123;<br>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="hljs-type">int</span> n, i;<br>    <span class="hljs-comment">// table未初始化或者长度为0，进行扩容</span><br>    <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-literal">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>        n = (tab = resize()).length;<br>    <span class="hljs-comment">// (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span><br>    <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-literal">null</span>)<br>        tab[i] = newNode(hash, key, value, <span class="hljs-literal">null</span>);<br>    <span class="hljs-comment">// 桶中已经存在元素</span><br>    <span class="hljs-keyword">else</span> &#123;<br>        Node&lt;K,V&gt; e; K k;<br>        <span class="hljs-comment">// 比较桶中第一个元素(数组中的结点)的hash值相等，key相等</span><br>        <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;<br>            ((k = p.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>                <span class="hljs-comment">// 将第一个元素赋值给e，用e来记录</span><br>                e = p;<br>        <span class="hljs-comment">// hash值不相等，即key不相等；为红黑树结点</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)<br>            <span class="hljs-comment">// 放入树中</span><br>            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="hljs-built_in">this</span>, tab, hash, key, value);<br>        <span class="hljs-comment">// 为链表结点</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 在链表最末插入结点</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">binCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; ; ++binCount) &#123;<br>                <span class="hljs-comment">// 到达链表的尾部</span><br>                <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-comment">// 在尾部插入新结点</span><br>                    p.next = newNode(hash, key, value, <span class="hljs-literal">null</span>);<br>                    <span class="hljs-comment">// 结点数量达到阈值(默认为 8 )，执行 treeifyBin 方法</span><br>                    <span class="hljs-comment">// 这个方法会根据 HashMap 数组来决定是否转换为红黑树。</span><br>                    <span class="hljs-comment">// 只有当数组长度大于或者等于 64 的情况下，才会执行转换红黑树操作，以减少搜索时间。否则，就是只是对数组扩容。</span><br>                    <span class="hljs-comment">// 具体可看treeifyBin源码</span><br>                    <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <br>                        treeifyBin(tab, hash);<br>                    <span class="hljs-comment">// 跳出循环</span><br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-comment">// 判断链表中结点的key值与插入的元素的key值是否相等</span><br>                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                    ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>                    <span class="hljs-comment">// 相等，跳出循环</span><br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-comment">// 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span><br>                p = e;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 表示在桶中找到key值、hash值与插入元素相等的结点</span><br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 记录e的value</span><br>            <span class="hljs-type">V</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> e.value;<br>            <span class="hljs-comment">// onlyIfAbsent为false或者旧值为null</span><br>            <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-literal">null</span>)<br>                <span class="hljs-comment">//用新值替换旧值</span><br>                e.value = value;<br>            <span class="hljs-comment">// 访问后回调</span><br>            afterNodeAccess(e);<br>            <span class="hljs-comment">// 返回旧值</span><br>            <span class="hljs-keyword">return</span> oldValue;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 结构性修改</span><br>    ++modCount;<br>    <span class="hljs-comment">// 实际大小大于阈值则扩容</span><br>    <span class="hljs-keyword">if</span> (++size &gt; threshold)<br>        resize();<br>    <span class="hljs-comment">// 插入后回调</span><br>    afterNodeInsertion(evict);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>3. 说说resize方法？</strong></p>
<p>随着HashMap中元素的数量越来越多，发生碰撞的概率将越来越大，所产生的子链长度就会越来越长，这样势必会影响HashMap的存取速度。为了保证HashMap的效率，系统必须要在某个临界点进行扩容处理，该临界点就是HashMap中元素的数量在数值上等于threshold（<strong>table数组长度 * 负载因子</strong>）</p>
<ul>
<li>threshold：表示最多能容纳Node的阈值，一般threshold=length * loadFactor</li>
<li>loadFactor：负载因子，默认是0.75，这个默认的值是基于时间和空间考虑而得到的一个比较平衡的点</li>
</ul>
<p>扩容过程：</p>
<ul>
<li>
<p>如果原数组长度超过最大容量（1&lt;&lt;30），不进行扩容，只是把阈值提高到Integer.MAX_VALUE；</p>
</li>
<li>
<p>否则<strong>将数组长度扩容为原来的两倍，阈值也扩大到原来的两倍</strong></p>
</li>
<li>
<p>随后进行数组的复制：</p>
</li>
<li>
<ul>
<li>如果只有一个元素，就直接赋值</li>
<li>如果是红黑树，就拆分红黑树</li>
<li>如果是多个元素的链表，需要进行重新映射，重新映射后，元素的索引要么不变，要么变为index+oldCap，具体原因如下图所示：</li>
</ul>
</li>
</ul>
<p><img src="http://longls777.oss-cn-beijing.aliyuncs.com/img/20170805175826627" srcset="/img/loading.gif" lazyload alt=""></p>
<p>图（a）表示扩容前的key1和key2两种key确定索引位置的示例，图（b）表示扩容后key1和key2两种key确定索引位置的示例</p>
<p>元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit（红色），因此新的index就会发生这样的变化：</p>
<p><img src="http://longls777.oss-cn-beijing.aliyuncs.com/img/20170805175936719" srcset="/img/loading.gif" lazyload alt=""></p>
<p>因此，我们在扩充HashMap的时候，<strong>不需要像JDK1.7的实现那样重新计算hash</strong>，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“<strong>原索引+oldCap</strong>”</p>
<p>这个设计确实非常的巧妙，既<strong>省去了重新hash值的时间</strong>，而且同时，<strong>由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了</strong>，这一块就是JDK1.8新增的优化点。</p>
<p>以下是一个扩容示例：</p>
<p><img src="http://longls777.oss-cn-beijing.aliyuncs.com/img/20170805180104619" srcset="/img/loading.gif" lazyload alt=""></p>
<p><strong>4. HashMap中hash函数是怎么实现的?</strong></p>
<p><strong>JDK1.8</strong></p>
<p>高16bit和低16bit做异或获得hash值，然后（n-1）&amp; hash获得下标</p>
<p>使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法，换句话说使用扰动函数之后可以减少碰撞</p>
<p>可以看到key==null时，直接返回0，所以<strong>HashMap中键为null的键值对，一定在第一个桶中</strong></p>
<p>绝大多数情况下length一般都小于2^16即小于65536。所以hash &amp; (length-1)；结果始终是hash的低16位与（length-1）进行&amp;运算。要是能让hash的高16位也参与运算，会让得到的下标更加散列</p>
<p>如何让高16位也参与运算呢？方法就是让hashCode()和自己的高16位进行^运算。由于与运算和或运算都会使得结果偏向0或者1，并不是均匀的概念，所以用异或</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object key)</span> &#123;<br>    <span class="hljs-type">int</span> h;<br>    <span class="hljs-comment">// key.hashCode()：返回散列值也就是hashcode</span><br>    <span class="hljs-comment">// ^ ：按位异或</span><br>    <span class="hljs-comment">// &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐</span><br>    <span class="hljs-keyword">return</span> (key == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>JDK1.7</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(<span class="hljs-type">int</span> h)</span> &#123;<br>    <span class="hljs-comment">// This function ensures that hashCodes that differ only by</span><br>    <span class="hljs-comment">// constant multiples at each bit position have a bounded</span><br>    <span class="hljs-comment">// number of collisions (approximately 8 at default load factor).</span><br><br>    h ^= (h &gt;&gt;&gt; <span class="hljs-number">20</span>) ^ (h &gt;&gt;&gt; <span class="hljs-number">12</span>);<br>    <span class="hljs-keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="hljs-number">7</span>) ^ (h &gt;&gt;&gt; <span class="hljs-number">4</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>5. 如何解决hash冲突？</strong></p>
<ul>
<li>
<p>HashMap使用的是链地址法（拉链法），将所有hash地址相同的元素都连接在同一链表中</p>
</li>
<li>
<p>除此之外，还有：</p>
</li>
<li>
<ul>
<li>开放地址法：外加增量d（线性探测再散列，二次探测再散列）</li>
<li>再哈希：对冲突的hash值再次进行hash处理，直到没有冲突</li>
<li>建立公共溢出区：建立公共溢出区存储所有哈希冲突的数据</li>
</ul>
</li>
</ul>
<p><strong>6. 说说HashMap的并发安全性问题？</strong></p>
<ul>
<li>HashMap的线程不安全体现在会<strong>造成死循环、数据丢失、数据覆盖</strong>这些问题。其中死循环和数据丢失是在JDK1.7中出现的问题，在JDK1.8中已经得到解决，然而1.8中仍会有数据覆盖的问题，即在并发执行HashMap的put操作时会发生数据覆盖的情况</li>
<li><strong>头插法会将链表的顺序翻转，这也是在多线程环境下会形成死循环的关键点</strong></li>
<li>在JDK1.8的putVal源码中，if((p = tab[i = (n - 1) &amp; hash]) == null)是判断是否出现hash碰撞，假设两个线程A、B都在进行put操作，并且hash函数计算出的插入下标是相同的，当线程A执行完这行代码后由于时间片耗尽导致被挂起，而线程B得到时间片后在该下标处插入了元素，完成了正常的插入，然后线程A获得时间片，由于之前已经进行了hash碰撞的判断，所以此时不会再进行判断，而是直接进行插入，这就导致了线程B插入的数据被线程A覆盖了，从而线程不安全</li>
</ul>
<p><strong>7. HashMap为什么引入红黑树而不是AVL树？</strong></p>
<p>上面这个问题也可以理解为：有了二叉查找树、平衡树（AVL）为什么还需要红黑树？</p>
<p>二叉查找树，也称有序二叉树（ordered binary tree），或已排序二叉树（sorted binary tree），是指一棵空树或者具有下列性质的二叉树：</p>
<ul>
<li>若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li>
<li>若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li>
<li>任意节点的左、右子树也分别为二叉查找树;</li>
<li>没有键值相等的节点（no duplicate nodes）</li>
</ul>
<p>因为一棵由N个结点随机构造的二叉查找树的高度为logN，所以顺理成章，二叉查找树的一般操作的执行时间为O(logN)。但二叉查找树若退化成了一棵具有N个结点的线性链后，则这些操作最坏情况运行时间为O(N)。</p>
<p>可想而知，我们不能让这种情况发生，为了解决这个问题，于是我们引申出了平衡二叉树，即AVL树，它对二叉查找树做了改进，在我们每插入一个节点的时候，必须保证每个节点对应的左子树和右子树的树高度差不超过1。如果超过了就对其进行左旋或右旋，使之平衡。</p>
<p>虽然平衡树解决了二叉查找树退化为近似链表的缺点，能够把查找时间控制在 O(logN)，不过却不是最佳的，因为平衡树要求每个节点的左子树和右子树的高度差至多等于1，这个要求实在是太严了，导致每次进行插入/删除节点的时候，几乎都会破坏平衡树的规则，进而我们都需要通过左旋和右旋来进行调整，使之再次成为一颗符合要求的平衡树。</p>
<p>显然，如果在那种插入、删除很频繁的场景中，平衡树需要频繁着进行调整，这会使平衡树的性能大打折扣，为了解决这个问题，于是有了红黑树。<strong>红黑树是不符合AVL树的平衡条件的，即每个节点的左子树和右子树的高度最多差1的二叉查找树，但是提出了为节点增加颜色，红黑树是用非严格的平衡来换取增删节点时候旋转次数的降低，任何不平衡都会在三次旋转之内解决，相较于AVL树为了维持平衡的开销要小得多。</strong></p>
<p>AVL树是严格平衡树，因此在增加或者删除节点的时候，根据不同情况，旋转的次数比红黑树要多，<strong>所以红黑树的插入效率相对于AVL树更高。单单在查找方面比较效率的话，由于AVL高度平衡，因此AVL树的查找效率比红黑树更高。</strong></p>
<p>对主要的几种平衡树作个比较，发现红黑树有着良好的稳定性和完整的功能，性能表现也很不错，综合实力强，在诸如STL的场景中需要稳定表现。实际应用中，若搜索的频率远远大于插入和删除，那么选择AVL，如果发生搜索和插入删除操作的频率差不多，应该选择红黑树</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/login_sonata/article/details/76598675%E9%9D%9E%E5%B8%B8%E4%B8%8D%E9%94%99">https://blog.csdn.net/login_sonata/article/details/76598675非常不错</a></p>
</blockquote>
<h1>五、ConcurrentHashMap</h1>
<p><strong>说说ConcurrentHashMap？</strong></p>
<p>Java1.7 中 ConcruuentHashMap 使用的<strong>分段锁</strong>，也就是每一个 Segment 上同时只有一个线程可以操作，每一个 Segment 都是一个类似 HashMap 数组的结构，它可以扩容，它的冲突会转化为链表。但是 Segment 的个数一但初始化就不能改变</p>
<p>Java1.8 中的 ConcruuentHashMap 使用的 <strong>Synchronized 锁加 CAS 的机制</strong>。结构也由 Java1.7 中的 Segment 数组 + HashEntry 数组 + 链表 进化成了 Node 数组 + 链表 / 红黑树，Node 是类似于一个 HashEntry 的结构。它的冲突再达到一定大小时会转化成红黑树，在冲突小于一定数量时又退回链表</p>
<p><img src="http://longls777.oss-cn-beijing.aliyuncs.com/img/ConcurrentHashMap%E5%82%A8%E5%AD%98%E7%BB%93%E6%9E%84.png" srcset="/img/loading.gif" lazyload alt="ConcurrentHashMap1.7储存结构"></p>
<p><img src="http://longls777.oss-cn-beijing.aliyuncs.com/img/ConcurrentHashMap%E7%BB%93%E6%9E%84.png" srcset="/img/loading.gif" lazyload alt="ConcurrentHashMap1.8储存结构"></p>
<p>ConcurrentHashMap 同样也分为 1.7 、1.8 版，两者在实现上略有不同。</p>
<h4 id="Base-1-7"><strong>Base 1.7</strong></h4>
<p>先来看看 1.7 的实现，下面是他的结构图：</p>
<p><img src="http://longls777.oss-cn-beijing.aliyuncs.com/img/ConcurrentHashMap1.7.png" srcset="/img/loading.gif" lazyload alt="ConcurrentHashMap1.7"></p>
<p>如图所示，是由 Segment 数组、HashEntry 组成，和 HashMap 一样，仍然是数组加链表。</p>
<p>它的核心成员变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Segment 数组，存放数据时首先需要定位到具体的 Segment 中。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">final</span> Segment&lt;K,V&gt;[] segments;<br><br><span class="hljs-keyword">transient</span> Set&lt;K&gt; keySet;<br><span class="hljs-keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;<br></code></pre></td></tr></table></figure>
<p>Segment 是 ConcurrentHashMap 的一个内部类，主要的组成如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Segment</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ReentrantLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br> <br>         <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">2249069246763182397L</span>;<br> <br>         <span class="hljs-comment">// 和 HashMap 中的 HashEntry 作用一样，真正存放数据的桶</span><br>         <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;<br> <br>         <span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> count;<br> <br>        <span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> modCount;<br><br>        <span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> threshold;<br><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">float</span> loadFactor;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>看看其中 HashEntry 的组成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashEntry</span>&lt;K,V&gt; &#123;<br>       <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> hash;<br>       <span class="hljs-keyword">final</span> K key;<br>       <span class="hljs-keyword">volatile</span> value;<br>       <span class="hljs-keyword">volatile</span> HashEntry&lt;K,V&gt; next;<br><br>       HashEntry(<span class="hljs-type">int</span> hash, K key, V value, HashEntry&lt;K,V&gt; next)&#123;<br>           <span class="hljs-built_in">this</span>.hash = hash;<br>           <span class="hljs-built_in">this</span>.key = key;<br>           <span class="hljs-built_in">this</span>.value = value;<br>           <span class="hljs-built_in">this</span>.next = next;<br>       &#125;<br></code></pre></td></tr></table></figure>
<p>和 HashMap 非常类似，<strong>唯一的区别就是其中的核心数据如 value ，以及链表都是 volatile 修饰的，保证了获取时的可见性</strong></p>
<p>原理上来说：ConcurrentHashMap 采用了分段锁技术，其中 Segment 继承于 ReentrantLock。不会像 HashTable 那样不管是 put 还是 get 操作都需要做同步处理，理论上 ConcurrentHashMap 支持 CurrencyLevel（Segment 数组数量）的线程并发。每当一个线程占用锁访问一个 Segment 时，不会影响到其他的 Segment。</p>
<p>下面也来看看核心的 put() 和 get() 方法：</p>
<p><strong>put() 方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;<br>      Segment&lt;K,V&gt; s;<br>      <span class="hljs-keyword">if</span> (value == <span class="hljs-literal">null</span>)<br>          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>      <span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> hash(key);<br>      <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;<br>      <span class="hljs-keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          <span class="hljs-comment">// nonvolatile; recheck</span><br>           (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="hljs-literal">null</span>) <span class="hljs-comment">//  in ensureSegment</span><br>          s = ensureSegment(j);<br>     <span class="hljs-keyword">return</span> s.put(key, hash, value, <span class="hljs-literal">false</span>);<br> &#125;<br></code></pre></td></tr></table></figure>
<p>首先是通过 key 定位到 Segment，之后在对应的 Segment 中进行具体的 put：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, <span class="hljs-type">int</span> hash, V value, <span class="hljs-type">boolean</span> onlyIfAbsent)</span> &#123;<br>          HashEntry&lt;K,V&gt; node = tryLock() ? <span class="hljs-literal">null</span> :<br>              scanAndLockForPut(key, hash, value);<br>          V oldValue;<br>          <span class="hljs-keyword">try</span> &#123;<br>              HashEntry&lt;K,V&gt;[] tab = table;<br>              <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> (tab.length - <span class="hljs-number">1</span>) &amp; hash;<br>              HashEntry&lt;K,V&gt; first = entryAt(tab, index);<br>              <span class="hljs-keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;<br>                 <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>                     K k;<br>                     <span class="hljs-keyword">if</span> ((k = e.key) == key ||<br>                         (e.hash == hash &amp;&amp; key.equals(k))) &#123;<br>                         oldValue = e.value;<br>                         <span class="hljs-keyword">if</span> (!onlyIfAbsent) &#123;<br>                             e.value = value;<br>                             ++modCount;<br>                         &#125;<br>                         <span class="hljs-keyword">break</span>;<br>                     &#125;<br>                     e = e.next;<br>                 &#125;<br>                 <span class="hljs-keyword">else</span> &#123;<br>                     <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">null</span>)<br>                         node.setNext(first);<br>                     <span class="hljs-keyword">else</span><br>                         node = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashEntry</span>&lt;K,V&gt;(hash, key, value, first);<br>                     <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> count + <span class="hljs-number">1</span>;<br>                     <span class="hljs-keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)<br>                         rehash(node);<br>                     <span class="hljs-keyword">else</span><br>                         setEntryAt(tab, index, node);<br>                     ++modCount;<br>                     count = c;<br>                     oldValue = <span class="hljs-literal">null</span>;<br>                     <span class="hljs-keyword">break</span>;<br>                 &#125;<br>             &#125;<br>         &#125; <span class="hljs-keyword">finally</span> &#123;<br>             unlock();<br>         &#125;<br>         <span class="hljs-keyword">return</span> oldValue;<br>     &#125;<br></code></pre></td></tr></table></figure>
<p>虽然 HashEntry 中的 value 是用 volatile 关键词修饰的，但是并不能保证并发的原子性，所以 put 操作时仍然需要加锁处理</p>
<p><strong>首先第一步的时候会尝试获取锁，如果获取失败肯定就有其他线程存在竞争，则利用 scanAndLockForPut() 自旋获取锁</strong></p>
<p><img src="http://longls777.oss-cn-beijing.aliyuncs.com/img/ConcurrentHashMap1.png" srcset="/img/loading.gif" lazyload alt=""></p>
<ol>
<li>尝试自旋获取锁</li>
<li>如果重试的次数达到了 MAX_SCAN_RETRIES 则改为阻塞锁获取，保证能获取成功</li>
</ol>
<p><img src="http://longls777.oss-cn-beijing.aliyuncs.com/img/ConcurrentHashMap2.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>再结合图看看 put 的流程</p>
<ol>
<li>将当前 Segment 中的 table 通过 key 的 hashcode 定位到 HashEntry</li>
<li>遍历该 HashEntry，如果不为空则判断传入的 key 和当前遍历的 key 是否相等，相等则覆盖旧的 value</li>
<li>为空则需要新建一个 HashEntry 并加入到 Segment 中，同时会先判断是否需要扩容</li>
<li>最后会解除在 1 中所获取当前 Segment 的锁</li>
</ol>
<p><strong>get() 方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(Object key)</span> &#123;<br>        Segment&lt;K,V&gt; s; <span class="hljs-comment">// manually integrate access methods to reduce overhead</span><br>        HashEntry&lt;K,V&gt;[] tab;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> hash(key);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;<br>        <span class="hljs-keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != <span class="hljs-literal">null</span> &amp;&amp;<br>            (tab = s.table) != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">for</span> (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile<br>                     (tab, ((<span class="hljs-type">long</span>)(((tab.length - <span class="hljs-number">1</span>) &amp; h)) &lt;&lt; TSHIFT) + TBASE);<br>                e != <span class="hljs-literal">null</span>; e = e.next) &#123;<br>               K k;<br>               <span class="hljs-keyword">if</span> ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))<br>                   <span class="hljs-keyword">return</span> e.value;<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>   &#125;<br></code></pre></td></tr></table></figure>
<p>get 逻辑比较简单：</p>
<p>只需要将 Key 通过 Hash 之后定位到具体的 Segment ，再通过一次 Hash 定位到具体的元素上</p>
<p>由于 HashEntry 中的 value 属性是用 volatile 关键词修饰的，保证了内存可见性，所以每次获取时都是最新值</p>
<p>ConcurrentHashMap 的 get 方法是非常高效的，<strong>因为整个过程都不需要加锁</strong></p>
<h4 id="Base-1-8"><strong>Base 1.8</strong></h4>
<p>1.7 已经解决了并发问题，并且能支持 N 个 Segment 这么多次数的并发，但依然存在 HashMap 在 1.7 版本中的问题，那就是查询遍历链表效率太低</p>
<p>因此 1.8 做了一些数据结构上的调整，首先来看下底层的组成结构：</p>
<p><img src="http://longls777.oss-cn-beijing.aliyuncs.com/img/ConcurrentHashMap1.8_.png" srcset="/img/loading.gif" lazyload alt="ConcurrentHashMap1.8"></p>
<p>看起来是不是和 1.8 HashMap 结构类似？</p>
<p>其中抛弃了原有的 Segment 分段锁，而采用了 <strong>CAS + synchronized</strong> 来保证并发安全性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>.Entry&lt;K,V&gt; &#123;<br>       <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> hash;<br>       <span class="hljs-keyword">final</span> K key;<br>       <span class="hljs-keyword">volatile</span> V val;<br>       <span class="hljs-keyword">volatile</span> Node&lt;K,V&gt; next;<br><br>       Node(<span class="hljs-type">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;<br>           <span class="hljs-built_in">this</span>.hash = hash;<br>           <span class="hljs-built_in">this</span>.key = key;<br>           <span class="hljs-built_in">this</span>.val = val;<br>           <span class="hljs-built_in">this</span>.next = next;<br>       &#125;<br><br>       <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> K <span class="hljs-title function_">getKey</span><span class="hljs-params">()</span>       &#123; <span class="hljs-keyword">return</span> key; &#125;<br>       <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title function_">getValue</span><span class="hljs-params">()</span>     &#123; <span class="hljs-keyword">return</span> val; &#125;<br>       <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span>   &#123; <span class="hljs-keyword">return</span> key.hashCode() ^ val.hashCode(); &#125;<br>       <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span>&#123; <span class="hljs-keyword">return</span> key + <span class="hljs-string">&quot;=&quot;</span> + val; &#125;<br>       <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title function_">setValue</span><span class="hljs-params">(V value)</span> &#123;<br>           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>();<br>       &#125;<br><br>       <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span> &#123;<br>           Object k, v, u; Map.Entry&lt;?,?&gt; e;<br>           <span class="hljs-keyword">return</span> ((o <span class="hljs-keyword">instanceof</span> Map.Entry) &amp;&amp;<br>                   (k = (e = (Map.Entry&lt;?,?&gt;)o).getKey()) != <span class="hljs-literal">null</span> &amp;&amp;<br>                   (v = e.getValue()) != <span class="hljs-literal">null</span> &amp;&amp;<br>                   (k == key || k.equals(key)) &amp;&amp;<br>                   (v == (u = val) || v.equals(u)));<br>       &#125;<br><br>       <span class="hljs-comment">/**</span><br><span class="hljs-comment">        * Virtualized support for map.get(); overridden in subclasses.</span><br><span class="hljs-comment">        */</span><br>       Node&lt;K,V&gt; <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> h, Object k)</span> &#123;<br>           Node&lt;K,V&gt; e = <span class="hljs-built_in">this</span>;<br>           <span class="hljs-keyword">if</span> (k != <span class="hljs-literal">null</span>) &#123;<br>               <span class="hljs-keyword">do</span> &#123;<br>                   K ek;<br>                   <span class="hljs-keyword">if</span> (e.hash == h &amp;&amp;<br>                       ((ek = e.key) == k || (ek != <span class="hljs-literal">null</span> &amp;&amp; k.equals(ek))))<br>                       <span class="hljs-keyword">return</span> e;<br>               &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-literal">null</span>);<br>           &#125;<br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure>
<p>将 1.7 中存放数据的 HashEntry 改为 Node，但作用都是相同的，其中的 val next 都用了 volatile 修饰，保证了可见性</p>
<p><strong>put() 方法</strong></p>
<p>重点来看看 put() 函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> V <span class="hljs-title function_">putVal</span><span class="hljs-params">(K key, V value, <span class="hljs-type">boolean</span> onlyIfAbsent)</span> &#123;<br> 		<span class="hljs-comment">//判断key,value是否为null,如果为null抛出空指针异常</span><br>        <span class="hljs-keyword">if</span> (key == <span class="hljs-literal">null</span> || value == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> spread(key.hashCode());<br>        <span class="hljs-type">int</span> <span class="hljs-variable">binCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;<br>            Node&lt;K,V&gt; f; <span class="hljs-type">int</span> n, i, fh;<br>            <span class="hljs-comment">//判断是否需要初始化</span><br>            <span class="hljs-keyword">if</span> (tab == <span class="hljs-literal">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>                tab = initTable();<br>             <span class="hljs-comment">//f 即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((f = tabAt(tab, i = (n - <span class="hljs-number">1</span>) &amp; hash)) == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> (casTabAt(tab, i, <span class="hljs-literal">null</span>,<br>                             <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="hljs-literal">null</span>)))<br>                    <span class="hljs-keyword">break</span>;                   <span class="hljs-comment">// no lock when adding to empty bin</span><br>            &#125;<br>            <span class="hljs-comment">//如果当前位置的 hashcode == MOVED == -1,则需要进行扩容</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((fh = f.hash) == MOVED)<br>                tab = helpTransfer(tab, f);<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">V</span> <span class="hljs-variable">oldVal</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>                <span class="hljs-comment">//如果都不满足，则利用 synchronized 锁写入数据</span><br>                <span class="hljs-keyword">synchronized</span> (f) &#123;<br>                    <span class="hljs-keyword">if</span> (tabAt(tab, i) == f) &#123;<br>                        <span class="hljs-keyword">if</span> (fh &gt;= <span class="hljs-number">0</span>) &#123;<br>                            binCount = <span class="hljs-number">1</span>;<br>                            <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;<br>                                K ek;<br>                                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                                    ((ek = e.key) == key ||<br>                                     (ek != <span class="hljs-literal">null</span> &amp;&amp; key.equals(ek)))) &#123;<br>                                    oldVal = e.val;<br>                                    <span class="hljs-keyword">if</span> (!onlyIfAbsent)<br>                                        e.val = value;<br>                                    <span class="hljs-keyword">break</span>;<br>                                &#125;<br>                                Node&lt;K,V&gt; pred = e;<br>                                <span class="hljs-keyword">if</span> ((e = e.next) == <span class="hljs-literal">null</span>) &#123;<br>                                    pred.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt;(hash, key,<br>                                                              value, <span class="hljs-literal">null</span>);<br>                                    <span class="hljs-keyword">break</span>;<br>                                &#125;<br>                            &#125;<br>                        &#125;<br>                        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (f <span class="hljs-keyword">instanceof</span> TreeBin) &#123;<br>                            Node&lt;K,V&gt; p;<br>                            binCount = <span class="hljs-number">2</span>;<br>                            <span class="hljs-keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,<br>                                                           value)) != <span class="hljs-literal">null</span>) &#123;<br>                                oldVal = p.val;<br>                                <span class="hljs-keyword">if</span> (!onlyIfAbsent)<br>                                    p.val = value;<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (binCount != <span class="hljs-number">0</span>) &#123;<br>                	<span class="hljs-comment">//如果数量大于 TREEIFY_THRESHOLD 则要转换为红黑树</span><br>                    <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)<br>                        treeifyBin(tab, i);<br>                    <span class="hljs-keyword">if</span> (oldVal != <span class="hljs-literal">null</span>)<br>                        <span class="hljs-keyword">return</span> oldVal;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        addCount(<span class="hljs-number">1L</span>, binCount);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>根据 key 计算出 hashcode</li>
<li>判断是否需要进行初始化</li>
<li>f 即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，<strong>利用 CAS 尝试写入，失败则自旋保证成功</strong></li>
<li>如果当前位置的 hashcode == MOVED == -1,则需要进行扩容</li>
<li><strong>如果都不满足，则利用 synchronized 锁写入数据</strong></li>
<li>如果数量大于 TREEIFY_THRESHOLD 则要转换为红黑树</li>
</ul>
<p><strong>get() 方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(Object key)</span> &#123;<br>       Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="hljs-type">int</span> n, eh; K ek;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> spread(key.hashCode());<br>       <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp;<br>           (e = tabAt(tab, (n - <span class="hljs-number">1</span>) &amp; h)) != <span class="hljs-literal">null</span>) &#123;<br>           <span class="hljs-comment">//根据计算出来的 hashcode 寻值，如果就在桶上那么直接返回值</span><br>           <span class="hljs-keyword">if</span> ((eh = e.hash) == h) &#123;<br>               <span class="hljs-keyword">if</span> ((ek = e.key) == key || (ek != <span class="hljs-literal">null</span> &amp;&amp; key.equals(ek)))<br>                   <span class="hljs-keyword">return</span> e.val;<br>           &#125;<br>           <span class="hljs-comment">//如果是红黑树那就按照树的方式获取值</span><br>           <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (eh &lt; <span class="hljs-number">0</span>)<br>               <span class="hljs-keyword">return</span> (p = e.find(h, key)) != <span class="hljs-literal">null</span> ? p.val : <span class="hljs-literal">null</span>;<br>           <span class="hljs-comment">//就不满足那就按照链表的方式遍历获取值。</span><br>           <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-literal">null</span>) &#123;<br>               <span class="hljs-keyword">if</span> (e.hash == h &amp;&amp;<br>                   ((ek = e.key) == key || (ek != <span class="hljs-literal">null</span> &amp;&amp; key.equals(ek))))<br>                   <span class="hljs-keyword">return</span> e.val;<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>   &#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>根据计算出来的 hashcode 寻址，如果就在桶上那么直接返回值</li>
<li>如果是红黑树那就按照树的方式获取值</li>
<li>就不满足那就按照链表的方式遍历获取值</li>
</ul>
<p>1.8 在 1.7 的数据结构上做了大的改动，采用红黑树之后可以保证查询效率（O(logn)），甚至取消了 ReentrantLock 改为了 synchronized，这样可以看出在新版的 JDK 中对 synchronized 优化是很到位的</p>
<h1>六、HashTable</h1>
<p><strong>Hashtable和HashMap的不同之处</strong></p>
<p><strong>1、继承的父类不同</strong></p>
<p>Hashtable继承自Dictionary类</p>
<p>HashMap继承自AbstractMap类，但二者都实现了Map接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashMap</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractMap</span>&lt;K,V&gt;<br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>&lt;K,V&gt;, Cloneable, Serializable &#123;&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hashtable</span>&lt;K,V&gt;<br>    <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Dictionary</span>&lt;K,V&gt;<br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>&lt;K,V&gt;, Cloneable, java.io.Serializable &#123;&#125;<br></code></pre></td></tr></table></figure>
<p><strong>2、线程安全性不同</strong></p>
<p>HashMap是线程不安全的</p>
<p>Hashtable是线程安全的，方法上加上了 Synchronized</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">putAll</span><span class="hljs-params">(Map&lt;? extends K, ? extends V&gt; t)</span> &#123;<br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">K</span>, ? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">V</span>&gt; e : t.entrySet())<br>            put(e.getKey(), e.getValue());<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Clears this hashtable so that it contains no keys.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span> &#123;<br>        Entry&lt;?,?&gt; tab[] = table;<br>        modCount++;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> tab.length; --index &gt;= <span class="hljs-number">0</span>; )<br>            tab[index] = <span class="hljs-literal">null</span>;<br>        count = <span class="hljs-number">0</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p><strong>3、是否提供contains方法</strong></p>
<p>HashMap把Hashtable的contains方法去掉了，改成containsValue和containsKey，因为contains方法容易让人引起误解</p>
<p>Hashtable则保留了contains，containsValue和containsKey三个方法，其中contains和containsValue功能相同</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">containsValue</span><span class="hljs-params">(Object value)</span> &#123;<br>        <span class="hljs-keyword">return</span> contains(value);<br>    &#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">contains</span><span class="hljs-params">(Object value)</span> &#123;<br>       <span class="hljs-keyword">if</span> (value == <span class="hljs-literal">null</span>) &#123;<br>           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>       &#125;<br><br>       Entry&lt;?,?&gt; tab[] = table;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> tab.length ; i-- &gt; <span class="hljs-number">0</span> ;) &#123;<br>           <span class="hljs-keyword">for</span> (Entry&lt;?,?&gt; e = tab[i] ; e != <span class="hljs-literal">null</span> ; e = e.next) &#123;<br>               <span class="hljs-keyword">if</span> (e.value.equals(value)) &#123;<br>                   <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>               &#125;<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>   &#125;<br></code></pre></td></tr></table></figure>
<p><strong>4、key和value是否允许null值</strong></p>
<p>Hashtable中，key和value都不允许出现null值。但是如果在Hashtable中有类似put(null,null)的操作，编译同样可以通过，因为key和value都是Object类型，但运行时会抛出NullPointerException异常，这是JDK的规范规定的</p>
<p>HashMap中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。当get()方法返回null值时，可能是 HashMap中没有该键，也可能使该键所对应的值为null。因此，在HashMap中不能由get()方法来判断HashMap中是否存在某个键， 而应该用containsKey()方法来判断</p>
<p><strong>5、内部实现使用的数组初始化和扩容方式不同</strong></p>
<p>HashTable在不指定容量的情况下的默认容量为11，而HashMap为16，Hashtable不要求底层数组的容量一定要为2的整数次幂，而HashMap则要求一定为2的整数次幂</p>
<p>Hashtable扩容时，将容量变为原来的2倍加1，而HashMap扩容时，将容量变为原来的2倍</p>
<blockquote>
<p><strong>在HashMap中，哈希桶数组table的长度length大小必须为2的n次方(一定是合数)，这是一种非常规的设计</strong>，常规的设计是把桶的大小设计为素数。相对来说素数导致冲突的概率要小于合数，具体证明可以参考<a target="_blank" rel="noopener" href="http://blog.csdn.net/liuqiyao_01/article/details/14475159%EF%BC%8CHashtable%E5%88%9D%E5%A7%8B%E5%8C%96%E6%A1%B6%E5%A4%A7%E5%B0%8F%E4%B8%BA11%EF%BC%8C%E5%B0%B1%E6%98%AF%E6%A1%B6%E5%A4%A7%E5%B0%8F%E8%AE%BE%E8%AE%A1%E4%B8%BA%E7%B4%A0%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%88Hashtable%E6%89%A9%E5%AE%B9%E5%90%8E%E4%B8%8D%E8%83%BD%E4%BF%9D%E8%AF%81%E8%BF%98%E6%98%AF%E7%B4%A0%E6%95%B0%EF%BC%89%E3%80%82HashMap%E9%87%87%E7%94%A8%E8%BF%99%E7%A7%8D%E9%9D%9E%E5%B8%B8%E8%A7%84%E8%AE%BE%E8%AE%A1%EF%BC%8C**%E4%B8%BB%E8%A6%81%E6%98%AF%E4%B8%BA%E4%BA%86%E5%9C%A8%E5%8F%96%E6%A8%A1%E5%92%8C%E6%89%A9%E5%AE%B9%E6%97%B6%E5%81%9A%E4%BC%98%E5%8C%96%EF%BC%8C%E5%90%8C%E6%97%B6%E5%87%8F%E5%B0%91%E5%86%B2%E7%AA%81**%EF%BC%8CHashMap%E5%AE%9A%E4%BD%8D%E5%93%88%E5%B8%8C%E6%A1%B6%E7%B4%A2%E5%BC%95%E4%BD%8D%E7%BD%AE%E6%97%B6%EF%BC%8C%E4%B9%9F%E5%8A%A0%E5%85%A5%E4%BA%86%E9%AB%98%E4%BD%8D%E5%8F%82%E4%B8%8E%E8%BF%90%E7%AE%97%E7%9A%84%E8%BF%87%E7%A8%8B%E3%80%82">http://blog.csdn.net/liuqiyao_01/article/details/14475159，Hashtable初始化桶大小为11，就是桶大小设计为素数的应用（Hashtable扩容后不能保证还是素数）。HashMap采用这种非常规设计，**主要是为了在取模和扩容时做优化，同时减少冲突**，HashMap定位哈希桶索引位置时，也加入了高位参与运算的过程。</a></p>
</blockquote>
<p><strong>6、计算hash值方式不同</strong></p>
<p>为了得到元素的位置，首先需要根据元素的 key计算出一个hash值，然后再用这个hash值来计算得到最终的位置。</p>
<p>HashMap有个hash方法重新计算了key的hash值，避免过高的hash冲突：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object key)</span> &#123;<br>        <span class="hljs-type">int</span> h;<br>        <span class="hljs-keyword">return</span> (key == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>注意这里计算hash值，先调用hashCode方法计算出来一个hash值，再将hash与右移16位后相异或，从而得到新的hash值。</p>
<p>HashMap在求hash值对应的位置索引时：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> (length - <span class="hljs-number">1</span>) &amp; hash<br></code></pre></td></tr></table></figure>
<p>将哈希表的大小固定为了2的幂，因为是取模得到索引值，故这样取模时，不需要做除法，只需要做位运算。位运算比除法的效率要高很多</p>
<p><strong>Hashtable通过计算key的hashCode()来得到hash值就为最终hash值</strong></p>
<p>HashTable在求hash值位置索引时计算index的方法：（从put方法中可以找到计算索引的方式）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> (hash &amp; <span class="hljs-number">0x7FFFFFFF</span>) % tab.length;<br></code></pre></td></tr></table></figure>
<p>&amp; 0x7FFFFFFF 的目的是为了将负的hash值转化为正值，因为hash值有可能为负数，而&amp;0x7FFFFFFF后，只有符号位改变，而后面的位都不变</p>
<p><strong>7 、解决hash冲突方式不同（地址冲突）</strong></p>
<p>Java8，HashMap中，当出现冲突时可以：</p>
<ol>
<li>如果冲突数量小于8，则是以链表方式解决冲突</li>
<li>而当冲突大于等于8，且Entry数组大于64时，就会将冲突的Entry转换为红黑树进行存储</li>
<li>而又当数量小于6时，则又转化为链表存储。</li>
</ol>
<p>而在HashTable中， 都是<strong>以链表方式</strong>存储</p>
<p><strong>8、迭代器不同</strong></p>
<p>HashMap 中的 Iterator 迭代器是 fail-fast 的，而 Hashtable 的 Enumerator 不是 fail-fast 的</p>
<p>快速失败（fail—fast）是java集合中的一种机制， 在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的内容进行了修改（增加、删除、修改），则会抛出ConcurrentModificationException</p>
<blockquote>
<p>摘自 <a target="_blank" rel="noopener" href="https://blog.csdn.net/hello_cmy/article/details/105138993">https://blog.csdn.net/hello_cmy/article/details/105138993</a></p>
</blockquote>
<h1>七、fail-fast机制</h1>
<p><strong>引入</strong></p>
<p>在前面介绍 ArrayList的扩容问题时对于modCount的操作没有详细说明，该变量的操作在add，remove等操作中都会发生改变。那么该变量到底有什么作用呢？</p>
<p><strong>简介</strong></p>
<p>fail-fast 机制，即快速失败机制，是java集合(Collection)中的一种错误检测机制。<strong>当在迭代集合的过程中该集合在结构上发生改变的时候，就有可能会发生fail-fast，即抛出 ConcurrentModificationException异常。fail-fast机制并不保证在不同步的修改下一定会抛出异常，它只是尽最大努力去抛出，所以这种机制一般仅用于检测bug。</strong></p>
<p><strong>fail-fast的出现场景</strong></p>
<p>在我们常见的java集合中就可能出现fail-fast机制，比如ArrayList，HashMap。在多线程和单线程环境下都有可能出现快速失败</p>
<p><strong>1、单线程环境下的fail-fast：</strong></p>
<p>ArrayList发生fail-fast例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>     List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">10</span> ; i++ ) &#123;<br>         list.add(i + <span class="hljs-string">&quot;&quot;</span>);<br>     &#125;<br>     Iterator&lt;String&gt; iterator = list.iterator();<br>     <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ;<br>     <span class="hljs-keyword">while</span>(iterator.hasNext()) &#123;<br>         <span class="hljs-keyword">if</span> (i == <span class="hljs-number">3</span>) &#123;<br>             list.remove(<span class="hljs-number">3</span>);<br>         &#125;<br>         System.out.println(iterator.next());<br>         i++;<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>该段代码定义了一个Arraylist集合，并使用迭代器遍历，在遍历过程中，刻意在某一步迭代中remove一个元素，这个时候，就会发生fail-fast</p>
<p><strong>HashMap发生fail-fast：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>     Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">10</span> ; i ++ ) &#123;<br>         map.put(i+<span class="hljs-string">&quot;&quot;</span>, i+<span class="hljs-string">&quot;&quot;</span>);<br>     &#125;<br>     Iterator&lt;Entry&lt;String, String&gt;&gt; it = map.entrySet().iterator();<br>     <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>     <span class="hljs-keyword">while</span> (it.hasNext()) &#123;<br>         <span class="hljs-keyword">if</span> (i == <span class="hljs-number">3</span>) &#123;<br>             map.remove(<span class="hljs-number">3</span>+<span class="hljs-string">&quot;&quot;</span>);<br>         &#125;<br>         Entry&lt;String, String&gt; entry = it.next();<br>         System.out.println(<span class="hljs-string">&quot;key= &quot;</span> + entry.getKey() + <span class="hljs-string">&quot; and value= &quot;</span> + entry.getValue());<br>         i++;<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>2、多线程环境下：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FailFastTest</span> &#123;<br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br> <br>     <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>           <span class="hljs-meta">@Override</span><br>           <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                Iterator&lt;String&gt; iterator = list.iterator();<br>                <span class="hljs-keyword">while</span>(iterator.hasNext()) &#123;<br>                     <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> iterator.next();<br>                     System.out.println(<span class="hljs-built_in">this</span>.getName() + <span class="hljs-string">&quot;:&quot;</span> + s);<br>                     <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                &#125;<br>                <span class="hljs-built_in">super</span>.run();<br>           &#125;<br>     &#125;<br> <br>     <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>           <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>           <span class="hljs-meta">@Override</span><br>           <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">10</span>) &#123;<br>                     System.out.println(<span class="hljs-string">&quot;thread2:&quot;</span> + i);<br>                     <span class="hljs-keyword">if</span> (i == <span class="hljs-number">2</span>) &#123;<br>                           list.remove(i);<br>                     &#125;<br>                     <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                     i ++;<br>                &#125;<br>           &#125;<br>     &#125;<br> <br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>           <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">10</span>;i++)&#123;<br>            list.add(i+<span class="hljs-string">&quot;&quot;</span>);<br>        &#125;<br>           <span class="hljs-type">MyThread1</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread1</span>();<br>           <span class="hljs-type">MyThread2</span> <span class="hljs-variable">thread2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread2</span>();<br>           thread1.setName(<span class="hljs-string">&quot;thread1&quot;</span>);<br>           thread2.setName(<span class="hljs-string">&quot;thread2&quot;</span>);<br>           thread1.start();<br>           thread2.start();<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>启动两个线程，分别对其中一个对list进行迭代，另一个在线程1的迭代过程中去remove一个元素，结果也是抛出了java.util.ConcurrentModificationException</p>
<h4 id="fail-fast的原理"><strong>fail-fast的原理</strong></h4>
<p>fail-fast是如何抛出ConcurrentModificationException异常的，又是在什么情况下才会抛出?</p>
<p>我们知道，对于集合如list，map类，我们都可以通过迭代器来遍历，而Iterator其实只是一个接口，具体的实现还是要看具体的集合类中的内部类去实现Iterator并实现相关方法。这里我们就以ArrayList类为例。在ArrayList中，当调用list.iterator()时，其源码是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Iterator&lt;E&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>	<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Itr</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>即它会返回一个新的Itr类，而Itr类是ArrayList的内部类，实现了Iterator接口，下面是该类的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * An optimized version of AbstractList.Itr</span><br><span class="hljs-comment">     */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Itr</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span>&lt;E&gt; &#123;<br>        <span class="hljs-type">int</span> cursor;       <span class="hljs-comment">// index of next element to return</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">lastRet</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">// index of last element returned; -1 if no such</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">expectedModCount</span> <span class="hljs-operator">=</span> modCount;<br> <br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> cursor != size;<br>        &#125;<br> <br>        <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>        <span class="hljs-keyword">public</span> E <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>            checkForComodification();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> cursor;<br>            <span class="hljs-keyword">if</span> (i &gt;= size)<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>();<br>            Object[] elementData = ArrayList.<span class="hljs-built_in">this</span>.elementData;<br>            <span class="hljs-keyword">if</span> (i &gt;= elementData.length)<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentModificationException</span>();<br>            cursor = i + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">return</span> (E) elementData[lastRet = i];<br>        &#125;<br> <br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">if</span> (lastRet &lt; <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>();<br>            checkForComodification();<br> <br>            <span class="hljs-keyword">try</span> &#123;<br>                ArrayList.<span class="hljs-built_in">this</span>.remove(lastRet);<br>                cursor = lastRet;<br>                lastRet = -<span class="hljs-number">1</span>;<br>                expectedModCount = modCount;<br>            &#125; <span class="hljs-keyword">catch</span> (IndexOutOfBoundsException ex) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentModificationException</span>();<br>            &#125;<br>        &#125;<br> <br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">forEachRemaining</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-built_in">super</span> E&gt; consumer)</span> &#123;<br>            Objects.requireNonNull(consumer);<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> ArrayList.<span class="hljs-built_in">this</span>.size;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> cursor;<br>            <span class="hljs-keyword">if</span> (i &gt;= size) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-keyword">final</span> Object[] elementData = ArrayList.<span class="hljs-built_in">this</span>.elementData;<br>            <span class="hljs-keyword">if</span> (i &gt;= elementData.length) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentModificationException</span>();<br>            &#125;<br>            <span class="hljs-keyword">while</span> (i != size &amp;&amp; modCount == expectedModCount) &#123;<br>                consumer.accept((E) elementData[i++]);<br>            &#125;<br>            <span class="hljs-comment">// update once at end of iteration to reduce heap write traffic</span><br>            cursor = i;<br>            lastRet = i - <span class="hljs-number">1</span>;<br>            checkForComodification();<br>        &#125;<br> <br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkForComodification</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">if</span> (modCount != expectedModCount)<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentModificationException</span>();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>其中，有三个属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> cursor;       <span class="hljs-comment">// index of next element to return</span><br><span class="hljs-type">int</span> <span class="hljs-variable">lastRet</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">// index of last element returned; -1 if no such</span><br><span class="hljs-type">int</span> <span class="hljs-variable">expectedModCount</span> <span class="hljs-operator">=</span> modCount;<br></code></pre></td></tr></table></figure>
<p>cursor是指集合遍历过程中的即将遍历的元素的索引，lastRet是cursor -1，默认为-1，即不存在上一个时，为-1，它主要用于记录刚刚遍历过的元素的索引</p>
<p>expectedModCount这个就是fail-fast判断的关键变量了，它初始值就为ArrayList中的modCount。（modCount是抽象类AbstractList中的变量，默认为0，而ArrayList 继承了AbstractList ，所以也有这个变量，modCount用于记录集合操作过程中作的修改次数，与size还是有区别的，并不一定等于size）</p>
<p>我们一步一步来看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>  	<span class="hljs-keyword">return</span> cursor != size;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>迭代器迭代结束的标志就是hasNext()返回false，而该方法就是用cursor游标和size(集合中的元素数目)进行对比，当cursor等于size时，表示已经遍历完成。</p>
<p>接下来看看最关心的next()方法，看看为什么在迭代过程中，如果有线程对集合结构做出改变，就会发生fail-fast：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="hljs-keyword">public</span> E <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>    checkForComodification();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> cursor;<br>    <span class="hljs-keyword">if</span> (i &gt;= size)<br>    	<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>();<br>    Object[] elementData = ArrayList.<span class="hljs-built_in">this</span>.elementData;<br>    <span class="hljs-keyword">if</span> (i &gt;= elementData.length)<br>    	<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentModificationException</span>();<br>    cursor = i + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> (E) elementData[lastRet = i];<br>&#125;<br></code></pre></td></tr></table></figure>
<p>从源码知道，每次调用next()方法，在实际访问元素前，都会调用<strong>checkForComodification</strong>方法，该方法源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkForComodification</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (modCount != expectedModCount)<br>    	<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentModificationException</span>();	<br>&#125;<br></code></pre></td></tr></table></figure>
<p>可以看出，该方法才是判断是否抛出ConcurrentModificationException异常的关键。在该段代码中，当modCount != expectedModCount时，就会抛出该异常。但是在一开始的时候，expectedModCount初始值默认等于modCount，为什么会出现modCount != expectedModCount，很明显expectedModCount在整个迭代过程除了一开始赋予初始值modCount外，并没有再发生改变，所以可能发生改变的就只有modCount，在前面关于ArrayList扩容机制的分析中，可以知道在ArrayList进行add，remove，clear等涉及到修改集合中的元素个数的操作时，modCount就会发生改变(modCount ++)</p>
<p><strong>所以当另一个线程(并发修改)或者同一个线程遍历过程中，调用相关方法使集合的个数发生改变，就会使modCount发生变化，这样在checkForComodification方法中就会抛出ConcurrentModificationException异常</strong></p>
<p>类似的，hashMap中发生的原理也是一样的</p>
<h4 id="避免fail-fast"><strong>避免fail-fast</strong></h4>
<p>了解了fail-fast机制的产生原理，接下来就看看如何解决fail-fast</p>
<p><strong>方法1</strong></p>
<p>在单线程的遍历过程中，如果要进行remove操作，可以调用<strong>迭代器的remove方法</strong>而不是集合类的remove方法。看看ArrayList中迭代器的<strong>remove方法</strong>的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> &#123;<br>     <span class="hljs-keyword">if</span> (lastRet &lt; <span class="hljs-number">0</span>)<br>     	<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>();<br>     checkForComodification();<br><br>    <span class="hljs-keyword">try</span> &#123;<br>    	ArrayList.<span class="hljs-built_in">this</span>.remove(lastRet);<br>    	cursor = lastRet;<br>    	lastRet = -<span class="hljs-number">1</span>;<br>    	expectedModCount = modCount;<br>    &#125; <span class="hljs-keyword">catch</span> (IndexOutOfBoundsException ex) &#123;<br>    	<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentModificationException</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>可以看到，该remove方法并不会修改modCount的值，并且不会对后面的遍历造成影响，因为该方法remove不能指定元素，只能remove当前遍历过的那个元素，所以调用该方法并不会发生fail-fast现象。该方法有局限性</p>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>          List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>          <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">10</span> ; i++ ) &#123;<br>               list.add(i + <span class="hljs-string">&quot;&quot;</span>);<br>          &#125;<br>          Iterator&lt;String&gt; iterator = list.iterator();<br>          <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ;<br>          <span class="hljs-keyword">while</span>(iterator.hasNext()) &#123;<br>               <span class="hljs-keyword">if</span> (i == <span class="hljs-number">3</span>) &#123;<br>                    iterator.remove(); <span class="hljs-comment">//迭代器的remove()方法</span><br>               &#125;<br>               System.out.println(iterator.next());<br>               i ++;<br>          &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p><strong>方法2</strong></p>
<p>使用java并发包(java.util.concurrent)中的类来代替 ArrayList 和HashMap</p>
<p>比如使用 <strong>CopyOnWriterArrayList</strong>代替 ArrayList， CopyOnWriterArrayList在是使用上跟 ArrayList几乎一样， CopyOnWriter是写时复制的容器(COW)，在读写时是线程安全的。该容器在对add和remove等操作时，并不是在原数组上进行修改，而是将原数组拷贝一份，在新数组上进行修改，待完成后，才将指向旧数组的引用指向新数组，所以对于 CopyOnWriterArrayList在迭代过程并不会发生fail-fast现象。但 CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性</p>
<p>对于HashMap，可以使用<strong>ConcurrentHashMap</strong>， ConcurrentHashMap采用了锁机制，是线程安全的。在迭代方面，ConcurrentHashMap使用了一种不同的迭代方式。在这种迭代方式中，当iterator被创建后集合再发生改变就不再是抛出ConcurrentModificationException，取而代之的是在改变时new新的数据从而不影响原有的数据 ，iterator完成后再将头指针替换为新的数据 ，这样iterator线程可以使用原来老的数据，而写线程也可以并发的完成改变。<strong>即迭代不会发生fail-fast，但不保证获取的是最新的数据</strong></p>
<blockquote>
<p>摘自<a target="_blank" rel="noopener" href="https://blog.csdn.net/zymx14/article/details/78394464">https://blog.csdn.net/zymx14/article/details/78394464</a></p>
</blockquote>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Java/" class="category-chain-item">Java</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E5%85%AB%E8%82%A1/" class="print-no-link">#八股</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Java集合详解</div>
      <div>https://lishilong.site/2023/04/23/Work/Java/Java容器详解/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Aaron</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年4月23日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/04/25/Work/Java/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AF%A6%E8%A7%A3/" title="JVM知识点详解">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">JVM知识点详解</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/04/14/Work/Practice/springboot/" title="SpringBoot">
                        <span class="hidden-mobile">SpringBoot</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  








    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
